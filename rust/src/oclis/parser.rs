// CAUTION:
// THIS FILE WAS GENERATED BY Oclis {{version}} BASED ON `oclis.ncl`.
// DO NOT EDIT MANUALLY!

use super::tokenizer::CliArgToken;
use super::types::{CliArgPrim, CliArgument, CliOption, Oclis};

fn find_flag_short<'a>(
    options: &'a Option<Vec<CliOption>>,
    flag_char: char,
) -> Option<&'a CliOption> {
    let short = flag_char.to_string();
    options
        .as_ref()?
        .iter()
        .find(|opt| opt.short_name.as_deref() == Some(&short))
}

fn find_flag_long<'a>(
    options: &'a Option<Vec<CliOption>>,
    flag_name: &str,
) -> Option<&'a CliOption> {
    options
        .as_ref()?
        .iter()
        .find(|opt| opt.name.as_deref() == Some(flag_name))
}

fn find_option_short<'a>(
    options: &'a Option<Vec<CliOption>>,
    flag_char: char,
) -> Option<&'a CliOption> {
    let short = flag_char.to_string();
    options
        .as_ref()?
        .iter()
        .find(|opt| opt.short_name.as_deref() == Some(&short))
}

fn find_option_long<'a>(
    options: &'a Option<Vec<CliOption>>,
    flag_name: &str,
) -> Option<&'a CliOption> {
    options
        .as_ref()?
        .iter()
        .find(|opt| opt.name.as_deref() == Some(flag_name))
}

fn find_sub_cmd<'a>(
    commands: &'a Option<Vec<Oclis>>,
    name: &str,
) -> Option<&'a Oclis> {
    commands.as_ref()?.iter().find(|cmd| cmd.name == name)
}

fn token_to_error(token: &CliArgToken) -> String {
    match token {
        CliArgToken::FlagLongToken(name) => {
            format!("Unknown flag: {name}")
        }
        CliArgToken::FlagShortToken(c) => {
            format!("Unknown flag: {c}")
        }
        CliArgToken::OptionShortToken(c, _) => {
            format!("Unknown option: {c}")
        }
        CliArgToken::OptionLongToken(name, _) => {
            format!("Unknown option: {name}")
        }
        _ => "Unknown token".to_string(),
    }
}

/// Verify that the remaining tokens are allowed
/// for the given command specification and return
/// the corresponding CliArguments.
fn verify_tokens_are_allowed(
    spec: &Oclis,
    tokens: &[CliArgToken],
) -> Result<Vec<CliArgument>, String> {
    let args = spec.arguments.as_deref().unwrap_or(&[]);
    let mut result: Vec<Result<CliArgument, String>> = Vec::new();
    let mut remaining = tokens;

    for arg in args {
        if remaining.is_empty() {
            break;
        }

        match (arg.arg_type.as_str(), &remaining[0]) {
            ("Text", CliArgToken::TextToken(txt)) => {
                result.push(Ok(CliArgument::ValArg(
                    CliArgPrim::TextArg(txt.clone()),
                )));
                remaining = &remaining[1..];
            }

            ("List-Text", CliArgToken::TextToken(_)) => {
                let list_args: Result<Vec<CliArgPrim>, String> = remaining
                    .iter()
                    .map(|tok| match tok {
                        CliArgToken::TextToken(t) => {
                            Ok(CliArgPrim::TextArg(t.clone()))
                        }
                        _ => {
                            Err(format!("Unsupported token: {tok:?}"))
                        }
                    })
                    .collect();
                result.push(list_args.map(CliArgument::ValArgList));
                remaining = &[];
            }

            _ => {
                result.push(Err(format!("Invalid argument: {arg:?}")));
                remaining = &remaining[1..];
            }
        }
    }

    result.into_iter().collect()
}

/// Determine the correct value of the CliArgTokens
/// by matching them against the spec.
/// Especially for the differentiation between Options and Flags.
/// Includes the main command as the first CliArgument.
pub fn tokens_to_cli_arguments(
    spec: &Oclis,
    tokens: &[CliArgToken],
) -> Result<Vec<CliArgument>, String> {
    // Validate main command token
    match tokens.first() {
        Some(CliArgToken::TextToken(cmd_name)) => {
            if spec.name != *cmd_name
                && spec.enforce_valid_name == Some(true)
            {
                return Err(format!(
                    "ERROR: \"{}\" is executed \
                     with the differently named executable \"{}\"",
                    spec.name, cmd_name
                ));
            }
        }
        _ => {
            return Err(
                "Something went wrong. \
                 The first token should be a command or a value."
                    .to_string(),
            );
        }
    }

    let main_cmd_arg = CliArgument::CmdArg(spec.name.clone());
    let rest = &tokens[1..];

    match rest.first() {
        // Help shortcuts
        Some(CliArgToken::FlagShortToken('h')) => {
            Ok(vec![main_cmd_arg, CliArgument::FlagShort('h')])
        }
        Some(CliArgToken::FlagLongToken(s)) if s == "help" => {
            Ok(vec![main_cmd_arg, CliArgument::FlagLong("help".into())])
        }
        Some(CliArgToken::TextToken(s)) if s == "help" => {
            Ok(vec![main_cmd_arg, CliArgument::CmdArg("help".into())])
        }

        // Version shortcuts
        Some(CliArgToken::FlagShortToken('v')) => {
            Ok(vec![main_cmd_arg, CliArgument::FlagShort('v')])
        }
        Some(CliArgToken::FlagLongToken(s)) if s == "version" => {
            Ok(vec![
                main_cmd_arg,
                CliArgument::FlagLong("version".into()),
            ])
        }
        Some(CliArgToken::TextToken(s)) if s == "version" => {
            Ok(vec![
                main_cmd_arg,
                CliArgument::CmdArg("version".into()),
            ])
        }

        // If first token after main command is a text token,
        // check if it's a subcommand or a value argument
        Some(CliArgToken::TextToken(name)) => {
            match find_sub_cmd(&spec.commands, name) {
                // Is a subcommand: recursively parse
                Some(cmd) => {
                    match tokens_to_cli_arguments(cmd, &tokens[1..]) {
                        Ok(args) => {
                            let mut result =
                                vec![CliArgument::CmdArg(spec.name.clone())];
                            result.extend(args);
                            Ok(result)
                        }
                        err => err,
                    }
                }
                // Is a value: verify tokens against arguments spec
                None => {
                    let cli_args =
                        verify_tokens_are_allowed(spec, &tokens[1..])?;
                    let mut result =
                        vec![CliArgument::CmdArg(spec.name.clone())];
                    result.extend(cli_args);
                    Ok(result)
                }
            }
        }

        // Flags and options: pair each token with its successor
        _ => {
            let remaining = &tokens[1..];
            let mut option_results: Vec<Result<CliArgument, String>> =
                Vec::new();

            for i in 0..remaining.len() {
                let token = &remaining[i];
                let next_token = remaining.get(i + 1);

                match token {
                    CliArgToken::FlagLongToken(flag_name) => {
                        match find_flag_long(&spec.options, flag_name) {
                            Some(flag_or_opt) => {
                                if flag_or_opt.argument.is_some() {
                                    // Flag has an argument spec,
                                    // check if next token is its value
                                    match next_token {
                                        Some(CliArgToken::TextToken(
                                            val,
                                        )) => {
                                            option_results.push(Ok(
                                                CliArgument::OptionLong(
                                                    flag_name.clone(),
                                                    CliArgPrim::TextArg(
                                                        val.clone(),
                                                    ),
                                                ),
                                            ));
                                        }
                                        _ => {
                                            option_results.push(Ok(
                                                CliArgument::FlagLong(
                                                    flag_name.clone(),
                                                ),
                                            ));
                                        }
                                    }
                                } else {
                                    option_results.push(Ok(
                                        CliArgument::FlagLong(
                                            flag_name.clone(),
                                        ),
                                    ));
                                }
                            }
                            None => {
                                // Maybe it's a long option
                                match find_option_long(
                                    &spec.options,
                                    flag_name,
                                ) {
                                    Some(_) => {
                                        option_results.push(Ok(
                                            CliArgument::OptionLong(
                                                flag_name.clone(),
                                                CliArgPrim::TextArg(
                                                    "TODO".into(),
                                                ),
                                            ),
                                        ));
                                    }
                                    None => {
                                        option_results.push(Err(
                                            token_to_error(token),
                                        ));
                                    }
                                }
                            }
                        }
                    }

                    CliArgToken::FlagShortToken(flag_char) => {
                        match find_flag_short(&spec.options, *flag_char) {
                            Some(_) => {
                                option_results.push(Ok(
                                    CliArgument::OptionShort(
                                        *flag_char,
                                        CliArgPrim::TextArg("TODO".into()),
                                    ),
                                ));
                            }
                            None => {
                                match find_option_short(
                                    &spec.options,
                                    *flag_char,
                                ) {
                                    Some(_) => {
                                        option_results.push(Ok(
                                            CliArgument::OptionShort(
                                                *flag_char,
                                                CliArgPrim::TextArg(
                                                    "TODO".into(),
                                                ),
                                            ),
                                        ));
                                    }
                                    None => {
                                        option_results.push(Err(
                                            token_to_error(token),
                                        ));
                                    }
                                }
                            }
                        }
                    }

                    CliArgToken::OptionShortToken(flag_char, _arg) => {
                        match find_flag_short(&spec.options, *flag_char) {
                            Some(_) => {
                                option_results.push(Ok(
                                    CliArgument::OptionShort(
                                        *flag_char,
                                        CliArgPrim::TextArg("TODO".into()),
                                    ),
                                ));
                            }
                            None => {
                                option_results
                                    .push(Err(token_to_error(token)));
                            }
                        }
                    }

                    CliArgToken::OptionLongToken(flag_name, _arg) => {
                        match find_flag_long(&spec.options, flag_name) {
                            Some(_) => {
                                option_results.push(Ok(
                                    CliArgument::OptionLong(
                                        flag_name.clone(),
                                        CliArgPrim::TextArg("TODO".into()),
                                    ),
                                ));
                            }
                            None => {
                                option_results
                                    .push(Err(token_to_error(token)));
                            }
                        }
                    }

                    CliArgToken::TextToken(txt) => {
                        // If prev result was an OptionLong,
                        // this token was already consumed as its value
                        match option_results.last() {
                            Some(Ok(CliArgument::OptionLong(_, _))) => {
                                // Skip: already consumed
                            }
                            _ => {
                                option_results.push(Ok(
                                    CliArgument::ValArg(
                                        CliArgPrim::TextArg(txt.clone()),
                                    ),
                                ));
                            }
                        }
                    }

                    _ => {}
                }
            }

            let opts: Vec<CliArgument> =
                option_results.into_iter().collect::<Result<_, _>>()?;

            let mut result = vec![main_cmd_arg];
            result.extend(opts);
            Ok(result)
        }
    }
}
