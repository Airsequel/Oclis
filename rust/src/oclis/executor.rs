// CAUTION:
// THIS FILE WAS GENERATED BY Oclis {{version}} BASED ON `oclis.ncl`.
// DO NOT EDIT MANUALLY!

use super::parser::tokens_to_cli_arguments;
use super::spec_embed::FILE_CONTENT;
use super::tokenizer::tokenize_cli_arguments;
use super::types::{Argument, CliArgument, CliOption, Oclis};

/// Context passed to the user's executor function
pub struct ExecutorContext {
    pub usage_string: String,
    pub command: Option<String>,
    pub arguments: Vec<CliArgument>,
}

fn parse_cli_spec(json_str: &str) -> Result<Oclis, String> {
    serde_json::from_str(json_str).map_err(|e| e.to_string())
}

fn build_args_string(args: &Option<Vec<Argument>>) -> String {
    match args {
        Some(args) => args
            .iter()
            .map(|arg| {
                let more_than_one =
                    if arg.arg_type.starts_with("List-") {
                        "\u{2026}" // â€¦
                    } else {
                        ""
                    };

                if arg.optional == Some(true) {
                    format!(" [{}{more_than_one}]", arg.name)
                } else {
                    format!(" {}", arg.name)
                }
            })
            .collect::<String>(),
        None => String::new(),
    }
}

fn short_and_long_flag(opt: &CliOption) -> String {
    let mut parts = Vec::new();

    if let Some(name) = &opt.name {
        let mut flag = format!("--{name}");
        if let Some(arg) = &opt.argument {
            let arg_str = format!("={}", arg.name);
            if arg.optional == Some(true) {
                flag.push_str(&format!("[{arg_str}]"));
            } else {
                flag.push_str(&arg_str);
            }
        }
        parts.push(flag);
    }

    if let Some(short) = &opt.short_name {
        parts.push(format!("-{short}"));
    }

    parts.join(", ")
}

fn calc_total_length(cmd: &Oclis) -> usize {
    cmd.name.len() + build_args_string(&cmd.arguments).len()
}

pub fn build_usage_string(spec: &Oclis) -> String {
    let help_option = CliOption {
        name: Some("help".into()),
        short_name: Some("h".into()),
        description: "Show this help message".into(),
        argument: None,
        optional: None,
        default: None,
    };

    let version_option = CliOption {
        name: Some("version".into()),
        short_name: Some("v".into()),
        description: "Show version".into(),
        argument: None,
        optional: None,
        default: None,
    };

    let mut all_options: Vec<&CliOption> = spec
        .options
        .as_ref()
        .map(|opts| opts.iter().collect())
        .unwrap_or_default();
    all_options.push(&help_option);
    all_options.push(&version_option);

    let has_options = !all_options.is_empty();

    let help_cmd = Oclis {
        name: "help".into(),
        description: "Show this help message".into(),
        version: None,
        enforce_valid_name: None,
        func_name: None,
        options: None,
        arguments: None,
        commands: None,
    };

    let version_cmd = Oclis {
        name: "version".into(),
        description: "Show version".into(),
        version: None,
        enforce_valid_name: None,
        func_name: None,
        options: None,
        arguments: None,
        commands: None,
    };

    let mut all_commands: Vec<&Oclis> = spec
        .commands
        .as_ref()
        .map(|cmds| cmds.iter().collect())
        .unwrap_or_default();
    all_commands.push(&help_cmd);
    all_commands.push(&version_cmd);

    // Calculate alignment widths
    let longest_option = all_options
        .iter()
        .map(|opt| short_and_long_flag(opt).len())
        .max()
        .unwrap_or(0);

    let longest_cmd = all_commands
        .iter()
        .map(|cmd| calc_total_length(cmd))
        .max()
        .unwrap_or(0);

    // Build usage header
    let mut output = format!("USAGE: {}", spec.name);

    if has_options {
        output.push_str(" [options\u{2026}]");
    }

    if spec.arguments.is_some() {
        output.push_str(&build_args_string(&spec.arguments));
    } else {
        output.push_str(" [command]");
    }
    output.push('\n');

    // Description
    output.push('\n');
    if !spec.description.is_empty() {
        output.push_str(&spec.description);
        output.push_str("\n\n");
    }

    // Options section
    output.push_str("OPTIONS:\n");
    for opt in &all_options {
        let flag_str = short_and_long_flag(opt);
        let padding = longest_option - flag_str.len();
        output.push_str(&flag_str);
        output.push_str("  ");
        output.push_str(&" ".repeat(padding));
        output.push_str(&opt.description);
        output.push('\n');
    }

    // Commands section (only if no positional arguments)
    if spec.arguments.is_none() {
        output.push_str("\nCOMMANDS:\n");
        for cmd in &all_commands {
            let cmd_str =
                format!("{}{}", cmd.name, build_args_string(&cmd.arguments));
            let padding = longest_cmd - calc_total_length(cmd);
            output.push_str(&cmd_str);
            output.push(' ');
            output.push_str(&" ".repeat(padding));
            output.push(' ');
            output.push_str(&cmd.description);
            output.push('\n');
        }
    }

    output
}

fn handle_help_or_version(
    spec: &Oclis,
    usage_string: &str,
    arg: &CliArgument,
) -> Option<Result<String, String>> {
    if *arg == CliArgument::CmdArg("help".into())
        || *arg == CliArgument::FlagLong("help".into())
        || *arg == CliArgument::FlagShort('h')
    {
        Some(Ok(usage_string.to_string()))
    } else if *arg == CliArgument::CmdArg("version".into())
        || *arg == CliArgument::FlagLong("version".into())
        || *arg == CliArgument::FlagShort('v')
    {
        let version = spec.version.as_deref().unwrap_or("0");
        Some(Ok(version.to_string()))
    } else {
        None
    }
}

/// Recursively calls the command with the given arguments.
fn call_command(
    spec: &Oclis,
    usage_string: &str,
    args: &[CliArgument],
    executor: &dyn Fn(ExecutorContext) -> Result<(), String>,
) -> Result<String, String> {
    let main_cmd = match args.first() {
        Some(CliArgument::CmdArg(name)) => Some(name.clone()),
        _ => None,
    };

    let rest = if args.len() > 1 { &args[1..] } else { &[] };

    match rest.first() {
        None => {
            // No arguments after command: show usage
            Err(usage_string.to_string())
        }

        Some(arg) => {
            // Check for help or version
            if let Some(result) =
                handle_help_or_version(spec, usage_string, arg)
            {
                return result;
            }

            match arg {
                CliArgument::CmdArg(cmd_name) => {
                    // Look up subcommand
                    let command_mb = spec
                        .commands
                        .as_ref()
                        .and_then(|cmds| {
                            cmds.iter().find(|cmd| cmd.name == *cmd_name)
                        });

                    match command_mb {
                        None => {
                            let err = format!(
                                "ERROR: Unknown command \"{cmd_name}\"\
                                 \n\n{usage_string}"
                            );
                            Err(err)
                        }
                        Some(cmd_spec) => {
                            let sub_usage =
                                build_usage_string(cmd_spec);
                            call_command(
                                cmd_spec,
                                &sub_usage,
                                rest,
                                executor,
                            )
                        }
                    }
                }

                _ => {
                    executor(ExecutorContext {
                        command: main_cmd,
                        usage_string: usage_string.to_string(),
                        arguments: rest.to_vec(),
                    })
                    .map(|_| String::new())
                }
            }
        }
    }
}

/// Main entry point. Call this from your main() function.
pub fn run(
    executor: impl Fn(ExecutorContext) -> Result<(), String>,
) {
    let spec = match parse_cli_spec(FILE_CONTENT) {
        Ok(s) => s,
        Err(e) => {
            eprintln!(
                "ERROR:\n\
                 The auto-generated CLI specification in spec_embed.rs \
                 could not be parsed.\n\
                 This should not be possible!\n\
                 Please make sure you didn't accidentally \
                 modify any Oclis files\n\
                 and report the following error at \
                 https://github.com/Airsequel/Oclis/issues/new:\n\n\
                 {e}"
            );
            std::process::exit(1);
        }
    };

    let args: Vec<String> = std::env::args().collect();

    if args.is_empty() {
        eprintln!(
            "The CLI app must be called with at least one argument"
        );
        std::process::exit(1);
    }

    let tokens = tokenize_cli_arguments(&args);
    match tokens_to_cli_arguments(&spec, &tokens) {
        Err(e) => {
            eprintln!("{e}");
            std::process::exit(1);
        }
        Ok(cli_args) => {
            let usage_string = build_usage_string(&spec);
            match call_command(&spec, &usage_string, &cli_args, &executor)
            {
                Ok(output) => {
                    if !output.is_empty() {
                        println!("{output}");
                    }
                }
                Err(e) => {
                    eprintln!("{e}");
                    std::process::exit(1);
                }
            }
        }
    }
}

/// For testing: run with explicit spec and args, returns result
/// instead of printing/exiting.
pub fn run_with(
    spec: &Oclis,
    args: &[String],
    executor: &dyn Fn(ExecutorContext) -> Result<(), String>,
) -> Result<String, String> {
    if args.is_empty() {
        return Err(
            "The CLI app must be called with at least one argument"
                .to_string(),
        );
    }

    let tokens = tokenize_cli_arguments(args);
    let cli_args = tokens_to_cli_arguments(spec, &tokens)?;
    let usage_string = build_usage_string(spec);
    call_command(spec, &usage_string, &cli_args, executor)
}
