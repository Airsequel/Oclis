// CAUTION:
// THIS FILE WAS GENERATED BY Oclis {{version}} BASED ON `oclis.ncl`.
// DO NOT EDIT MANUALLY!

use super::types::CliArgPrim;

/// Intermediate representation of CLI arguments.
/// May not yet differentiate correctly between Options and Flags,
/// or between CmdArgs and ValArgs.
#[derive(Debug, Clone, PartialEq)]
pub enum CliArgToken {
    /// Could be a command or a value argument
    TextToken(String),
    FlagShortToken(char),
    FlagLongToken(String),
    /// `-n=3`
    OptionShortToken(char, CliArgPrim),
    /// `-i=3,4,5`
    OptionShortListToken(char, Vec<CliArgPrim>),
    /// `--num=3`
    OptionLongToken(String, CliArgPrim),
    /// `--items=3,4,5`
    OptionLongListToken(String, Vec<CliArgPrim>),
    ValArgToken(CliArgPrim),
    ValArgListToken(Vec<CliArgPrim>),
    SeparatorToken,
}

/// One argument can lead to multiple CliArgTokens.
/// E.g. `-ab` -> `[FlagShortToken('a'), FlagShortToken('b')]`
pub fn tokenize_cli_argument(arg: &str) -> Vec<CliArgToken> {
    let chars: Vec<char> = arg.chars().collect();

    match chars.as_slice() {
        // `--` separator
        ['-', '-'] => vec![CliArgToken::SeparatorToken],

        // `--name=value` or `--name`
        ['-', '-', rest @ ..] => {
            let rest_str: String = rest.iter().collect();
            if let Some((key, value)) = rest_str.split_once('=') {
                vec![CliArgToken::OptionLongToken(
                    key.to_string(),
                    CliArgPrim::TextArg(value.to_string()),
                )]
            } else {
                vec![CliArgToken::FlagLongToken(rest_str)]
            }
        }

        // `-n=value` or `-ab` combined flags or `-a` single flag
        ['-', short_flag, rest @ ..] => {
            if rest.first() == Some(&'=') {
                let value: String = rest[1..].iter().collect();
                vec![CliArgToken::OptionShortToken(
                    *short_flag,
                    CliArgPrim::TextArg(value),
                )]
            } else if rest.is_empty() {
                vec![CliArgToken::FlagShortToken(*short_flag)]
            } else {
                // Combined short flags: -abc -> [FlagShort a, FlagShort b, FlagShort c]
                let mut tokens = vec![CliArgToken::FlagShortToken(*short_flag)];
                for c in rest {
                    tokens.push(CliArgToken::FlagShortToken(*c));
                }
                tokens
            }
        }

        // Plain text (command name or value)
        _ => vec![CliArgToken::TextToken(arg.to_string())],
    }
}

/// Parse CLI arguments into a list of CliArgTokens.
pub fn tokenize_cli_arguments(arguments: &[String]) -> Vec<CliArgToken> {
    arguments
        .iter()
        .flat_map(|arg| tokenize_cli_argument(arg))
        .collect()
}
